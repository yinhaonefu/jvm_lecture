package com.shengsiyuan.jvm.bytecode;

/**
 * 栈帧：stack frame
 *
 * 栈帧用于帮助虚拟机执行方法调用与方法执行的数据结构，每一个线程都有自己的栈帧，不存在并发问题。封装了方法的局部变量表、
 * 动态链接信息、方法的返回地址及操作数栈等信息。
 *
 * 动态链接信息指的是，A类中存在对B类的方法调用，那在编译期间A类和B类之间的地址关系是不知道的，有两种情况下才会知道
 * 第一种是在类加载的时候，第二种是当调用真的发生时才会确定目标方法的地址是什么。基于第二种情况，引申出来了两个概念
 * 符号引用和直接引用 符号引用体现在常量池中的标识，直接引用可以看作是直接指向目标内存地址的指针
 * 有些符号引用在类的加载阶段就会转换成直接引用，称为静态解析
 * 有些符号引用在每次调用的时候才转换成直接引用，称为动态链接，这体现在Java的多态性
 *
 * 静态解析的4种情形
 * 1. 静态方法
 * 2. 父类方法
 * 3. 构造方法
 * 4. 私有方法（无法被重写）
 * 以上4类方法称作非虚方法，它们是在类加载阶段就可以将符号引用转换为直接引用
 *
 * 方法调用字节码指令
 * 1. invokeinterface: 调用接口中的方法，实际上是在运行期决定的，决定到底调用实现该接口的哪个对象的特定方法，是个动态过程
 * 2. invokestatic: 调用静态方法
 * 3. invokespecial: 调用自己的私有方法，构造方法(<init>)以及父类的方法
 * 4. invokevirtual: 调用虚方法，运行期动态查找的过程
 * 5. invokegynamic: 动态调用方法，jdk1.7引入
 *
 */
public class MyTest4 {

    public static void test(){
        System.out.println("test invoked");
    }

    public static void main(String[] args) {
        test();
    }
}
