package com.shengsiyuan.jvm.memory;


import java.util.ArrayList;
import java.util.List;

/**
 * JVM内存空间
 * 虚拟机栈：里面存储的数据叫做Stack Frame（栈帧）。例如局部变量表，局部变量表会存储java中的8个原生数据类型以及引用类型。每个虚拟机栈归属于某个线程，属于线程的私有内存空间
 * 程序计数器：记录程序一行一行执行，下一行在什么地方，描述了执行顺序。同时当线程切换时，也需要记录上一个线程被挂起时程序执行的位置。属于线程的私有内存空间
 * 本地方法栈：native方法，与虚拟机栈类似，主要用于处理本地方法，hotspot虚拟机把本地方法栈和虚拟机栈合并了
 * 堆（Heap）：JVM管理的最大一块内存空间，new出来的对象都存在堆上。与堆相关的一个重要的概念就是垃圾收集器，现代几乎所有的垃圾收集器都是采用的分代收集算法。所以，堆空间也基于这一点进行了相应的划分：新生代与老年代，Eden空间，From Survivor空间与To Survivor空间
 * 方法区：存储对象元数据信息，Class对象的信息，从JDK1.8开始使用元空间（meta space）代替永久代
 * 运行时常量池：方法区的一部分内容
 * 直接内存：又称对外内存，不是由JVM直接管理的，属于操作系统上的内存，由JVM申请在操作系统上开辟一块直接内存，通过堆上的DirectByteBuffer来操作直接内存。与Java NIO密切相关
 *
 * 关于Java对象的创建过程
 * new关键字创建对象的三个步骤
 * 1. 在堆内存中创建出对象的实例
 * 2. 为对象的实例成员变量赋初值
 * 3. 将对象的引用返回
 *
 * 指针碰撞：前提是堆中的空间通过一个指针进行分割，一侧是已经被占用的空间，另一侧是未被占用的空间
 * 空闲列表：前提是堆内存空间中已被使用与未被使用额空间是交织在一起的，这时虚拟机就需要通过一个列表来记录哪些空间是可以使用的，哪些空间是已被使用的。接下来找出可以容纳新创建对象的且未被使用的空间，在此空间存放该对象，同时还要修改列表上的记录。
 *
 * 出现这两种情况的主要原因是和垃圾回收算法息息相关的，有的算法只回收空间并不压缩就产生了空闲列表，有的算法回收内存空间后会将空闲空间压缩移动就产生了指针碰撞
 *
 * 对象在内存中的布局：
 * 1. 对象头
 * 2. 实例数据，即我们在一个类中所声明的各项信息
 * 3. 对齐填充，可选
 *
 * 引用访问对象的方式
 * 1. 使用句柄的方式
 * 2. 使用直接指针的方式
 *
 * -Xms5m -Xmx5m -XX:+HeapDumpOnOutOfMemoryError
 * 添加-XX:+HeapDumpOnOutOfMemoryError为了能够在内存溢出时输入dump文件，使用jvisualvm装入该文件进行分析
 *
 */
public class MyTest1 {
    public static void main(String[] args) {
        List<MyTest1> list = new ArrayList<>();
        for ( ; ; ){
            list.add(new MyTest1());//执行后内存溢出，生成dump文件

            System.gc();//使用jvisualvm监控
        }
    }
}
